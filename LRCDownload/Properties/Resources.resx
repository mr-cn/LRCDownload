<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Netease" xml:space="preserve">
    <value>// Created by Elia &lt;elia.of.little@gmail.com&gt;
// Update 2016-08-09 19:36
// Require:
// - foobar2000 v1.3.3+ with ESLyric v0.3.5+
// Thanks: 
// - Moon for netease's api &gt;&gt;&gt; [http://moonlib.com/606.html]
// - ttsping for ESLyric and sample scripts
// - keperlia, ABC超人1, etc
//
// Another NeteaseCloudMusicScript here:
//  [http://tieba.baidu.com/p/4651402375?pn=1]
//
// Issues || bug reports || advices are all encouraged!

var header = {
    'Referer': 'http://music.163.com/',
    'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36'
    //'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36'
};
var cookie = "appver=2.0.2";

var api = {
    "lyric": 'http://music.163.com/api/song/lyric',
    "query": "http://music.163.com/api/search/get/"
};

// Set false if do not want console output infos.
var dbg = true;

// Eng | CHN, separated by `|', but only one will be displayed in lyric search
// window (`Source' column) acording to foobar2000.exe's lang.
function get_my_name() {
    return "NeteaseCloudMusic|网易云音乐";
}

function get_version() {
    return "0.0.1";
}

function get_author() {
    return "Elia";
}

function start_search(info, callback) {

    var url;
    var title = info.Title;
    var artist = info.Artist;

    var http_client = utils.CreateHttpClient();
    var json_txt;

    // Set headers, Cookie, postData
    add_headers(header, http_client);
    http_client.addCookie("Cookie", cookie);
    http_client.addPostData(get_search_params(artist, title));

    json_txt = http_client.Request(api.query, "POST");
    if (http_client.StatusCode != 200) {
        console("Request url &gt;&gt;&gt;" + api.query + "&lt;&lt;&lt; error: " + http_client.StatusCode);
        return;
    }

    var obj_result = json(json_txt)["result"];
    var songs;
    if (obj_result.songs) {
        songs = obj_result.songs;
        console(songs.length);
    } else {
        console(json_txt);
        return;
    }

    console(json_txt);

    var _new_lyric = callback.CreateLyric();
    var id;

    // get lyrics
    for (var i = 0; i &lt; songs.length; i++) {
        if (callback.IsAborting()) {
            console("User aborted!");
            break;
        }
        try {
            id = songs[i]["id"];
            artist = songs[i].artists[0].name;
            title = songs[i].name;
            album = songs[i].album.name;
        } catch (e) { };
        url = api.lyric + "?os=pc&amp;id=" + id + "&amp;lv=-1&amp;kv=-1&amp;tv=-1";
        add_headers(header, http_client);
        json_txt = http_client.Request(url);
        if (http_client.StatusCode != 200) {
            console("Request url &gt;&gt;&gt;" + url + "&lt;&lt;&lt; error: " + http_client.StatusCode);
            continue;
        }
        // 
        try {
            _new_lyric.LyricText = json(json_txt).lrc.lyric;
            _new_lyric.Title = title;
            _new_lyric.Artist = artist;
            _new_lyric.Album = album;
            _new_lyric.Location = url;
            _new_lyric.Source = get_my_name();
            callback.AddLyric(_new_lyric);
            (i%2 == 0) &amp;&amp; callback.Refresh();
        } catch (e) {
            console("Unkown, failed to add lyric");
        }
    }

    _new_lyric.Dispose();

}

function add_headers(header, client) {
    for (var i in header) {
        client.addHttpHeader(i, header[i]);
    }
}

function get_search_params(artist, title, limit, type, offset) {
    if (limit == undefined) limit = 10;
    if (type == undefined) type = 1;
    if (offset == undefined) offset = 0;
    artist = process_keywords(artist);
    title = process_keywords(title);
    return "s=" + artist + "+" + title + "&amp;limit=" + limit + "&amp;type=" + type + "&amp;offset=" + offset;
};


function process_keywords(str) {
    var s = str;
    s = s.toLowerCase();
    s = s.replace(/\'|·|\$|\&amp;|–/g, "");
    //truncate all symbols
    s = s.replace(/\(.*?\)|\[.*?]|{.*?}|（.*?/g, "");
    s = s.replace(/[-/:-@[-`{-~]+/g, "");
    s = s.replace(/[\u2014\u2018\u201c\u2026\u3001\u3002\u300a\u300b\u300e\u300f\u3010\u3011\u30fb\uff01\uff08\uff09\uff0c\uff1a\uff1b\uff1f\uff5e\uffe5]+/g, "");
    return s;
}

function json(text) 
{
    try{
        var data=JSON.parse(text);
        return data;
    }catch(e){
        return false;
    }
}

function console(s) {
    if (dbg) {
        return;
    }
    fb.trace(get_my_name() + " $&gt;  " + s);
};


// TODO: grab klyric &amp;&amp; tlyric too.</value>
  </data>
</root>